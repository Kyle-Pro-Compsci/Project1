#!/usr/bin/env python3

import json
import socket
import ssl # Secure Sockets Layer, aka TLS (Transport Layer Security)
import sys 
import argparse

# Unsecure flag: 0b391a1a67b5083430f5bd1bc7de5703a821eb16664fffaffd9a9fc7e2044ee4

# Set command line input flags and arguments
parser = argparse.ArgumentParser("Find the correct wordle guess from a given host socket")
parser.add_argument('-p', '--port', type=int, help="Set the port", default=27993)
parser.add_argument('-s', help="Opt to use an encrypted TLS socket connection", action='store_true')
parser.add_argument('hostname', help="Specify the name of the server")
parser.add_argument('username', help="NEU Username to login with")
args = parser.parse_args()

# Global Variables
ID = "to be set"
STARTING_WORD = 'slate'
#HELLO_MESSAGE = '{"type": "hello", "northeastern_username": "koo.k"}\n'

# Encode a string word in to a JSON guess and returns it
def encode_guess(guess):
    if(len(guess) != 5):
        print("Warning! Guess is not a 5 character word")
    guess_dict = {
        "type": "guess",
        "id": ID,
        "word": guess
    }
    guess_json = json.dumps(guess_dict) + '\n'
    return guess_json

# Take a guess word, wordle reply array, and a word list -> returns the word list
def filter_wordlist(guess, marks, word_list):

    new_wordlist = []

    green = {} # Dict of letters where their position is known
    yellow = {} # Set of letters that are in the word (but wrong place)
    red = {} # Set of letters that are not in the word
    for i in range(len(marks)):
        if(marks[i] == 0):
            red[i] = guess[i]
        if(marks[i] == 1):
            yellow[i] = guess[i] # May need to change to remove words where yellow letters are in same spot
        if(marks[i] == 2): # Need to make key the letter index in case of repeating letters (e.g. apple)
            green[i] = guess[i]
    print("green:", green, "yellow:", yellow, "red:", red)

    for word in word_list: # Remove wrong words
        skip = False
        for g in green:
            if(guess[g] != word[g]):
                skip = True
                break
        if(skip): continue
        for y in yellow:
            if(yellow[y] not in word) or (yellow[y] == word[y]):
                skip = True
                break
        if(skip): continue
        for r in red:
            # Marks can have duplicate letters - only remove letters if they are not mentioned in green or yellow
            if(red[r] in word) and (red[r] not in list(green.values())) and (red[r] not in list(yellow.values())):
                skip = True
                break
        if(skip): continue
        new_wordlist.append(word)
    #for item in new_wordlist[:10]:
    #    print(item)
    return new_wordlist

# Main function communicating with the socket. Can be given an unencoded socket and a wrapped encoded socket to get both results.
def socket_comm(sock):
    hello_dict = {'type': 'hello', 'northeastern_username' : args.username}
    hello_message = json.dumps(hello_dict) + '\n'

    sock.send(hello_message.encode())
    hello_data_json = sock.recv(1024) #may need to set into a loop to make sure recieved whole JSON 
    hello_data = json.loads(hello_data_json)
    print(hello_data)
    global ID # Global variable being modified
    ID = hello_data['id']

    # Creating a List of eligible words
    word_list_file = open('project1-words.txt', 'r')
    data = word_list_file.read()
    word_list_file.close()
    word_list = data.split('\n')
    print("starting len", len(word_list))
    print("starting list preview:", word_list[:10])

    guess = STARTING_WORD
    loop = True # Set false when accept reply is given
    while(loop):
        print("Guessing word:", guess)
        guess_json = encode_guess(guess)
        sock.send(guess_json.encode())
        reply_json = sock.recv(1024) #May have to change this to loop until end char received
        reply = json.loads(reply_json)
        print("reply:", reply)

        if (reply['type'] == 'retry'):
            word_list = word_list[1:]# Remove last guess from word_list to prevent loops
            mark_dict = reply['guesses'][len(reply['guesses']) - 1] # Take the latest guess mark combo
            marks = mark_dict['marks']
            word_list = filter_wordlist(guess, marks, word_list)
            print(word_list[:10])
            print("list length:", len(word_list))
            guess = word_list[0]

        elif (reply['type'] == 'bye'):
            print("Correct word is: ", guess)
            print("Flag is: ", reply['flag'])
            loop = False
            sys.exit()

        else:
            print("Error JSON type received not recognized. Exiting.")
            sys.exit()

def wordle_client():

    #host = args.hostname
    #port = args.port
    host = 'proj1.3700.network'
    port = 27993
    #context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)

    # with socket.create_connection((host, port)) as sock:
    #     with context.wrap_socket(sock, server_hostname=host) as sock_w:
    #         print(sock_w.version())

    print(type(host), host)
    print(type(port), port)

    with socket.create_connection((host, port)) as sock:
        print("whyy")
        socket_comm(sock)

def test(alist):
    for i in alist:
        if i == 'a':
            print(i)
            i = 'b'
    print(alist)

def test_remove():
    #Correct word: craft
    #First guess: slate
    word_list = ['craft', 'crane', 'slate', 'seeth', 'abaft', 'grape', 'apple', 'sraft', 'frape', 'toapo', 'cratt', 'teapo']
    test_marks = [0, 0, 2, 1, 0]
    word_list = filter_wordlist('slate', test_marks, word_list)
    print(word_list)
    


# Entry point of the program LOOK UP WHY THIS IS ON STACK
if __name__ == '__main__':

    print(args)
    wordle_client()
    #encode_guess('slate')
    #test_remove()

